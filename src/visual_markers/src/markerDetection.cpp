#include <iostream>
#include <fstream>
#include <ostream>

using namespace std;

#include <stdio.h>
#include <cstdlib>
#include <math.h>
#include <getopt.h>
#include <string>

#include "oasystem.h"

//#include "openarconfig.h"
//#include "system-gl.h"
//#include "system.h"
#include "debuginfo.h"
#include <SDL.h>
#include <cv.h>
#include "highgui.h"

#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/calib3d/calib3d.hpp"


#include "oaengine.h"
#include "oasimpleobj.h"
#include "ar.h"
#include "gridloc.h"
#include "bploc.h"

//includes do zezoca
#include <glm/glm.hpp>
#include <glm/gtx/transform.hpp>
#include "glm/ext.hpp"
#include "pose.h"

#include <ros/ros.h>
#include <signal.h>
#include "geometry_msgs/Pose2D.h"
#include "RMPISR/odomError.h"
#include "RMPISR/resetrmp.h"
#include "RMPISR/markerdetected.h"
#include "std_msgs/Float32MultiArray.h"
#include <time.h>
#include <vector>
#include <string>

double odomX, odomY, odomTheta;

/*! function to be called in case of an error generated by OpenCV
 */
int errcb( int status, const char* func_name,  const char* err_msg, const char* file_name, int line, void* userdata ){
  cerr <<"Error on "<<func_name<<", msg= "<<err_msg<<" file "<< file_name<<" line"<< line<<endl;

  cerr<< "OpenCV Error: "<<cvErrorStr(status) << endl;
  abort();
#ifdef _WIN32
  return 0;
#endif
}


//#include <btBulletDynamicsCommon.h>

using namespace OpenAR;


GridLocator * startgridloc(ProjectiveCamera * cam){
  GridLocator* loc=new GridLocator();
  loc->setCameraModel(cam);
  return loc;
}


BPLocator * startbploc(ProjectiveCamera * cam){
  BPLocator * loc=new BPLocator(2);
  loc->setCameraModel(cam);
  return loc;
}


void serciceCall(std_msgs::Float32MultiArray array1,RMPISR::odomError srv, ros::ServiceClient client ){
  srv.request.pose = array1;

  client.call(srv);

}


void serciceCallOnce(std_msgs::Float32MultiArray array1,RMPISR::resetrmp srv2, ros::ServiceClient client2 ){
  srv2.request.pose = array1;

  client2.call(srv2);

}

//funcao que le valores dos marcadores do ficheiro texto
std::vector<float> readFile(string path){
  float value;
  string discard;
  std::vector<float> aux;

  ifstream myReadFile;
  myReadFile.open(path.c_str());
  if (myReadFile.is_open()) {
    while (myReadFile >> discard >> value) {
      
      //fscanf(myReadFile,"%s %f",discard, value)
      aux.push_back(value);

          
    }
  }

  else cout << "Não consegui aceder ao ficheiro." << endl;
  myReadFile.close();


//percorrer o vector e fazer print dos valores
for (std::vector<float>::const_iterator i = aux.begin(); i != aux.end(); ++i)
    std::cout << *i << ' ';
  cout << endl;


return aux;

}



/*
void odomCallback(const geometry_msgs::Pose2D::ConstPtr& msg){
odomX=msg->x;
odomY=msg->y;
odomTheta=msg->theta;

//ROS_INFO("OdometriaFun: X= %f, Y= %f, e Theta= %f", odomX,odomY,odomTheta);
}*/

int main(int argc, char **argv){
  ros::init(argc, argv, "markerDetection_node");
  ros::NodeHandle nh;
  ros::ServiceClient client, client2, client3;
  ros::Subscriber odom_sub;
  // nh.serviceClient<nome do ficheiro>("nome em que o serviço é disponibilizado");
  client = nh.serviceClient<RMPISR::odomError>("odomError");
  client2 = nh.serviceClient<RMPISR::resetrmp>("resetRMP");
  client3 = nh.serviceClient<RMPISR::markerdetected>("markerdetected");
  //odom_sub =  nh.subscribe("odomUpdater",10,odomCallback);
  RMPISR::odomError srv;
  RMPISR::resetrmp srv2;
  RMPISR::markerdetected srv3;
  geometry_msgs::Pose2D trueOdom;
  bool entrar = true;
  bool once = true;
  std::vector<float> setValues;
  std::ofstream outfile ("test.txt");
  time_t rawtime;
  struct tm * timeinfo;
  int tabid[9] = {111,127,200,78,135,1,134,45,102};
  int sizeid = 9;



  cvRedirectError(errcb);
  MarkerLocator * locator=NULL;
  bool capture_from_cam=false;
  unsigned long start, now;
  int viewangle=5;  
  int numM=0, id, id_ant; 
  
  // CvMatrix rotation(3,1,CV_64FC1);
  //CvMatrix translation(3,1,CV_64FC1);
  
  Pose pose, poseaux; 
  ProjectiveCamera cammodel;

  cv::Mat  iframe;
  cv::Mat  frame;
  cv::Mat  img;
  cv::Mat  img2;
  bool doundistort=false;


//-----------------------------------------------------//

setValues = readFile("/home/rmp/catkin_ws/src/visual_markers/src/markersSettings.txt");
//setValues = readFile("/home/rmp/catkin_ws/src/visual_markers/src/markersSettingsGlobal.txt");

  // rmpTc -> rigid tranf rmp to camera
  // cTm -> camara to marker (script calculates)
  // rmpTm -> rmp to marker
  // mTrmp -> marker to rmp
  // wTrmp -> word to rmp

  glm::mat4 rmpTc;
  rmpTc[0] = glm::vec4(1.0,0.0,0.0,0.0);
  rmpTc[1] = glm::vec4(0.0,0.0,-1.0,0.0);
  rmpTc[2] = glm::vec4(0.0,1.0,0.0,0.0);
  rmpTc[3] = glm::vec4(0.0,350.0,750.0,1.0);
  glm::mat4 cTm,rmpTm, mTrmp, wTrmp;

  glm::mat4 wTc,inv_cTm;




//-----------------------------------------------------//

  // Transf World to Marker
  //glm::mat4 M0, M1, M2, M3;
  //glm::mat4 M_use;

/*
  M0[0] = glm::vec4(0.0,1.0,0.0,0.0);
  M0[1] = glm::vec4(0.0,0.0,1.0,0.0);
  M0[2] = glm::vec4(1.0,0.0,0.0,0.0);
  M0[3] = glm::vec4(0.0,0.0,800.0,1.0);

  M1[0] = glm::vec4(1.0,0.0,0.0,0.0);
  M1[1] = glm::vec4(0.0,0.0,1.0,0.0);
  M1[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  M1[3] = glm::vec4(1800.0,5800.0,800.0,1.0);

  M2[0] = glm::vec4(0.0,-1.0,0.0,0.0);
  M2[1] = glm::vec4(0.0,0.0,1.0,0.0);
  M2[2] = glm::vec4(-1.0,0.0,0.0,0.0);
  M2[3] = glm::vec4(5000.0,4000.0,800.0,1.0);

  M3[0] = glm::vec4(-1.0,0.0,0.0,0.0);
  M3[1] = glm::vec4(0.0,0.0,1.0,0.0);
  M3[2] = glm::vec4(0.0,1.0,0.0,0.0);
  M3[3] = glm::vec4(0.0,0.0,800.0,1.0);
*/

  //para a demostração
  glm::mat4 M_use, Ma, Mb, Mc, Md, Mc2, novo, Me, Mf, Mh, Mi, Mj, Mk;
  std_msgs::Float32MultiArray array;


  //para o teste:
  //1º ponto - Marker nº 111
  Ma[0] = glm::vec4(1.0,0.0,0.0,0.0);
  Ma[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Ma[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Ma[3] = glm::vec4(setValues.at(1),setValues.at(2),setValues.at(3),1.0);

  //2º ponto - Marker nº 127
  Mb[0] = glm::vec4(1.0,0.0,0.0,0.0);
  Mb[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mb[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mb[3] = glm::vec4(setValues.at(4),setValues.at(5),setValues.at(6),1.0);

  //4º ponto - Marker nº 150
  Mc[0] = glm::vec4(0.0,1.0,0.0,0.0);
  Mc[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mc[2] = glm::vec4(1.0,0.0,0.0,0.0);
  Mc[3] = glm::vec4(setValues.at(7),setValues.at(8),setValues.at(9),1.0);

  Mc2[0] = glm::vec4(-1.0,0.0,0.0,0.0);
  Mc2[1] = glm::vec4(0.0,0.0,-1.0,0.0);
  Mc2[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mc2[3] = glm::vec4(setValues.at(10),setValues.at(11),setValues.at(12),1.0);

  //3º ponto - Marker nº 200
  Md[0] = glm::vec4(0.0,1.0,0.0,0.0);
  Md[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Md[2] = glm::vec4(1.0,0.0,0.0,0.0);
  Md[3] = glm::vec4(setValues.at(10),setValues.at(11),setValues.at(12),1.0);

  // Marker nº 78
  Me[0] = glm::vec4(-1.0,0.0,0.0,0.0);
  Me[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Me[2] = glm::vec4(0.0,1.0,0.0,0.0);
  Me[3] = glm::vec4(setValues.at(13),setValues.at(14),setValues.at(15),1.0);

  // Marker nº 135
  Mf[0] = glm::vec4(-1.0,0.0,0.0,0.0);
  Mf[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mf[2] = glm::vec4(0.0,1.0,0.0,0.0);
  Mf[3] = glm::vec4(setValues.at(16),setValues.at(17),setValues.at(18),1.0);

  // Marker nº 1
  Mh[0] = glm::vec4(-1.0,0.0,0.0,0.0);
  Mh[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mh[2] = glm::vec4(0.0,1.0,0.0,0.0);
  Mh[3] = glm::vec4(setValues.at(19),setValues.at(20),setValues.at(21),1.0);

  // Marker nº 134
  Mi[0] = glm::vec4(1.0,0.0,0.0,0.0);
  Mi[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mi[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mi[3] = glm::vec4(setValues.at(22),setValues.at(23),setValues.at(24),1.0);

  // Marker nº 45
  Mj[0] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mj[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mj[2] = glm::vec4(-1.0,0.0,0.0,0.0);
  Mj[3] = glm::vec4(setValues.at(25),setValues.at(26),setValues.at(27),1.0);

  // Marker nº 255
  Mk[0] = glm::vec4(1.0,0.0,0.0,0.0);
  Mk[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mk[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mk[3] = glm::vec4(setValues.at(28),setValues.at(29),setValues.at(30),1.0);







  //-------------------------------------------------------------------------------------------

// usados no mundo real
/*
  Ma[0] = glm::vec4(0.0,-1.0,0.0,0.0);
  Ma[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Ma[2] = glm::vec4(-1.0,0.0,0.0,0.0);
  Ma[3] = glm::vec4(setValues.at(1),setValues.at(2),setValues.at(3),1.0);

  //2º ponto - Marker nº 127
  Mb[0] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mb[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mb[2] = glm::vec4(-1.0,0.0,0.0,0.0);
  Mb[3] = glm::vec4(setValues.at(4),setValues.at(5),setValues.at(6),1.0);

  //4º ponto - Marker nº 150
  Mc[0] = glm::vec4(1.0,0.0,0.0,0.0);
  Mc[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mc[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mc[3] = glm::vec4(setValues.at(7),setValues.at(8),setValues.at(9),1.0);

  Mc2[0] = glm::vec4(1.0,0.0,0.0,0.0);
  Mc2[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Mc2[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Mc2[3] = glm::vec4(setValues.at(10),setValues.at(11),setValues.at(12),1.0);


  //3º ponto - Marker nº 200
  Md[0] = glm::vec4(1.0,0.0,0.0,0.0);
  Md[1] = glm::vec4(0.0,0.0,1.0,0.0);
  Md[2] = glm::vec4(0.0,-1.0,0.0,0.0);
  Md[3] = glm::vec4(setValues.at(10),setValues.at(11),setValues.at(12),1.0);
  */

 //-------------------------------------------------------------------------------------------  

  // This part corresponds to the typical initialization of an application
  
  oaRenderer window;
  
  window.Init();
  window.CreateWindow(); 
  window.FinishSetup();
  window.setCamPose(0.0, 10.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, M_PI_2 );

  

  oaEngine engine;


  CvFont font;
  char msg[80];
  char msg3[80], msg4[80];
  //cvInitFont( &font, CV_FONT_HERSHEY_COMPLEX, 1, 1, 0.0, 5, CV_AA );
  // engine.SetViewingAngle(30);
  viewangle=30;
  oaShader * shader1;
  shader1=engine.loadShaders("texture.vs","texture.fs");
 
  //window.SetViewingAngle(glm::radians((float)viewangle));

  //window.SetWindowTitle("MarkerLocator");

  start = System::GetTicks();
  //SDL_EnableKeyRepeat(50, 50);
  //
  // a small trick for getting images from a camera or from an AVI file
  //
  cv::VideoCapture * capture;
  if( argc == 1 || (argc == 2 && strlen(argv[1]) == 1 && isdigit(argv[1][0]))){
      capture = new cv::VideoCapture( argc == 2 ? argv[1][0] - '0' : 0 );
#ifndef __APPLE__
      capture->set(CV_CAP_PROP_FRAME_WIDTH,800);
      capture->set(CV_CAP_PROP_FRAME_HEIGHT,600);
#endif
  }
  else if( argc == 2 ){
      capture = new cv::VideoCapture( argv[1] );
      capture_from_cam=false;
  }
  
  *capture >> iframe;

  if (!cammodel.LoadIntrinsicFile("camparam.cal")){
  printf("Error loading camera parameters\n");
  exit(1);
  } else 
      printf("Camera parameters loaded\n");

  oaCamera * cam;
  cam = new oaCamera;
  //cam->perspective(
  std::cout << "K="<<cammodel.IntrinsicMatrix<<std::endl;
  
  
  cam->setIntrinsics(cammodel,iframe.cols,iframe.rows,1,50000);
  //cam->setCamPose(Pose(0,0,0,1,0,0,M_PI));
  cam->lookat(0,0,0,0,0,1,0,-1,0);
  
  //window.SetCamera(cam);
  
  //window.camera->setIntrinsics(cammodel,800,600,1,50000);
  

  // Insert an object in engine
  //IplImage *tex=cvLoadImage(DATADIR "/OpenAR/textures/tijolos1.bmp");

  // the main cycle
  // capture -> process -> display & process events


    if (locator)
  delete locator;
    locator=startbploc(&cammodel);



   
  for(;;) {

  now = System::GetTicks();
    
  // capture one image
  *capture >> iframe ;

  if (doundistort){
      cv::undistort(iframe,frame,cammodel.IntrinsicMatrix,cammodel.DistortionCoefficients);
  }
  else 
      frame = iframe.clone();       

  if (locator){
    numM=locator->DetectMarker(frame);
    //numM=0;
    locator->DrawMarkerFeatures(frame);

    //printf("MarkerTotal = %d with ID: %d\n",numM, id);

    //if (id =! id_ant){




        for(int lk=0;lk<numM;lk++){
      
          locator->useCVPose=true;
          pose=locator->getMarkerPose(lk);
          id=locator->getMarkerId(lk);

          //sprintf(msg3,"Measure to marker center: %f",pose.position.norm());
          //cv::putText(frame,msg3,cvPoint(0,50),cv::FONT_HERSHEY_SIMPLEX,1,cv::Scalar::all(100),3,8);
          //M_use=Ma;

          if (id==111){
            M_use=Ma;
          }

          else if (id==127){
            M_use=Mb;
          }

          else if (id==200){
            M_use=Md;
          }

          else if (id==150){
            M_use=Mc;
          }

          else if (id==134){
            M_use=Mi;
          }

          else if (id==78){
            M_use=Me;
          }

          else if (id==102){
            M_use=Mf;
          }

          else if (id==1){
            M_use=Mh;
          }

          else if (id==45){
            M_use=Mj;
          }
      
          //glm::vec4 novo =wTrmp*glm::vec4(1.0,0.0,0.0,0.0);
          //float norma = sqrt(pow(novo[0],2)+pow(novo[1],2));
          

        //printf("Xcam=  %f Ycam=  %f ThCam=  %f \n",(wTc[3][0])/1000, (wTc[3][1])/1000, atan2((wTc[0][1]),(wTc[0][0])) );
        //printf("NOVO: x=  %f y=  %f theta=  %f \n",((wTrmp[3][0])/1000), ((wTrmp[3][1])/1000), atan2((wTrmp[0][1]/norma),(wTrmp[0][0]/norma)) );

        //sprintf(msg4,"x=  %f y=  %f theta=  %f ",((wTrmp[3][0])/1000), ((wTrmp[3][1])/1000), (atan2((wTrmp[0][1]),(wTrmp[0][0]))) );
        //cv::putText(frame,msg4,cvPoint(0,100),cv::FONT_HERSHEY_SIMPLEX,1,cv::Scalar::all(100),3,8);

        //printf("M_use %s \n", glm::to_string(M_use).c_str() );


          
        id_ant=id;

        for (int i = 0; i < sizeid; i++)
        {
          if(id == tabid[i]){
            cTm = pose.getRT();
            inv_cTm=glm::inverse(cTm);
            wTc=M_use*inv_cTm;
            
            
            rmpTm=rmpTc*cTm;
            mTrmp=glm::inverse(rmpTm);
            wTrmp=M_use*mTrmp;

            
            for (int i=0; i<=3; i++){
              for(int j=0; j<=3; j++){

                array.data.push_back(wTrmp[i][j]);
              }
            }

            entrar=true;
            break;
           }           
        }

        if (once && entrar){
          printf("Inicializacao da odometria!    ID= %d \n", id);
          serciceCallOnce(array,srv2,client2);
          once = false;
          printf("x=  %f y=  %f theta=  %f \n",((wTrmp[3][0])/1000), ((wTrmp[3][1])/1000), (atan2((wTrmp[0][1]),(wTrmp[0][0]))) );
          ros::Duration(1).sleep();
        }


        if(entrar){
          printf("\nENTROU CHAMADA SERVICO!!  ID= %d \n", id );
          time ( &rawtime );
          timeinfo = localtime ( &rawtime );
          
          // call do servico que envia o calculo do erro para ser adicionado à odometria original
          serciceCall(array,srv,client);
          client3.call(srv3);
          printf("x=  %f y=  %f theta=  %f \n",((wTrmp[3][0])/1000), ((wTrmp[3][1])/1000), (atan2((wTrmp[0][1]),(wTrmp[0][0]))) );
          

        } else{
          printf("\nID não reconhecido!");
        }


          array.data.clear();
          entrar = false;
          ros::spinOnce();
        }
  
  //cv::putText(frame,msg,cvPoint(10,50),cv::FONT_HERSHEY_SIMPLEX,1, cv::Scalar::all(255),3,8);
  // set it as the opengl scene background

  //engine.SetBGImage(frame);
  

  //engine.renderScene(&window);

  SDL_Event ev;
  while(SDL_PollEvent(&ev)) {
    switch (ev.key.keysym.sym){
    case  SDLK_ESCAPE:
      case SDL_QUIT:
        return 0;
      break;

      case SDLK_q:
        return 0;

      default:
        //std::cout << "key"<< std::endl;
      break;
    }
    break;
  }


  }

}
  
  outfile.close();
  return 0;



}

